package business

import (
	"fmt"
	"github.com/yael-castro/godi/internal/model"
	"github.com/yael-castro/godi/internal/repository"
	"net/url"
)

// CodeGenerator generator of authorization codes
type CodeGenerator interface {
	// GenerateCode generates a random model.AuthorizationCode
	GenerateCode() model.AuthorizationCode
}

// CodeGeneratorFunc functional interface for CodeGenerator
type CodeGeneratorFunc func() model.AuthorizationCode

// GenerateCode executes f() to generate a random code
func (f CodeGeneratorFunc) GenerateCode() model.AuthorizationCode {
	return f()
}

// _ "implement" constraint for ProofKeyCodeExchange
var _ Authorizer = (*AuthorizationCodeGrant)(nil)

// AuthorizationCodeGrant made the validations that corresponds to the Authorization Code Grant flow
type AuthorizationCodeGrant struct {
	finder repository.Finder
}

// SetFinder initializes the instance of repository.ClientFinder used to get the model.Client
func (c *AuthorizationCodeGrant) SetFinder(finder repository.ClientFinder) {
	c.finder = finder
}

// Authorize validate the client model.Client obtained with the received data (model.Authorization)
//
// In resume...
//
// 1. Identifies the client using the client id and client secret
//
// 2. Validates the received state
//
// 3. Validates the redirect uri
func (c AuthorizationCodeGrant) Authorize(auth model.Authorization) *url.URL {
	q := url.Values{}

	var (
		client model.Client
		i      interface{}
		err    error
	)

	// Validating state
	if !auth.State.IsValid() {
		q.Set("error", model.InvalidRequest.Error())
		q.Set("error_description", "invalid state")
		goto end
	}

	i, err = c.finder.Find(auth.ClientId)
	// Obtaining the application data by client id
	if _, ok := err.(model.NotFound); ok {
		q.Set("error", model.UnauthorizedClient.Error())
		q.Set("error_description", err.Error())
		goto end
	}

	// Handling internal server errors
	if err != nil {
		q.Set("error", model.ServerError.Error())
		q.Set("error_description", err.Error())
		goto end
	}

	client = i.(model.Client)

	if client.Secret != "" {
		// Validating the secret
		if client.Secret != auth.ClientSecret {
			q.Set("error", model.UnauthorizedClient.Error())
			q.Set("error_description", "client credentials does not match")
			goto end
		}
	}

	if !client.IsValidOrigin(auth.RedirectURL.String()) {
		q.Set("error", model.UnauthorizedClient.Error())
		q.Set("error_description", fmt.Sprintf(`invalid redirect uri "%s"`, auth.RedirectURL.RawPath))
	}

end:
	auth.RedirectURL.RawQuery = q.Encode()
	return auth.RedirectURL
}

// _ "implement" constraint for ProofKeyCodeExchange
var _ Authorizer = ProofKeyCodeExchange{}

// ProofKeyCodeExchange is the "Authorization Code Grant" flow with the extension "Proof Key for Code Exchange"
// for the OAuth 2.0 protocol
type ProofKeyCodeExchange struct {
	// Authorizer must be an implementation of Authorize Code Grant Flow
	Authorizer
	// CodeGenerator generate a code to save and validate the requests
	CodeGenerator
	repository.Storage
}

// Authorize validates the code_challenge and code_challenge_method and, if all is ok,
// saves the session of this authorization requests using the random code generated by
// the CodeGenerator
func (p ProofKeyCodeExchange) Authorize(auth model.Authorization) *url.URL {
	uri := p.Authorizer.Authorize(auth)

	if uri.Query().Get("error") != "" { // Redirect URI validation
		return uri
	}

	q := url.Values{}
	code := p.GenerateCode()

	if !auth.CodeChallengeMethod.IsValid() {
		q.Set("error", model.InvalidRequest.Error())
		q.Set("error_description", "invalid code_challenge_method, must be PLAIN or S256")
		goto end
	}

	// TODO validate correctly the code challenge based on the model.CodeChallengeMethod
	if !auth.CodeChallenge.IsValid() {
		q.Set("error", model.InvalidRequest.Error())
		q.Set("error_description", "invalid code_challenge")
		goto end
	}

	if err := p.Storage.Create(string(code), auth); err != nil {
		if _, ok := err.(model.DuplicateRecord); ok {
			q.Set("error", model.InvalidRequest.Error())
			q.Set("error_description", err.Error())
			goto end
		}

		q.Set("error", model.ServerError.Error())
		q.Set("error_description", err.Error())
	}

	q.Set("code", string(code))
	q.Set("state", string(auth.State))

end:
	uri.RawQuery = q.Encode()
	return uri
}
