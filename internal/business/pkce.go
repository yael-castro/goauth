package business

import (
	"fmt"
	"github.com/go-redis/redis/v8"
	"github.com/google/uuid"
	"github.com/yael-castro/godi/internal/model"
	"github.com/yael-castro/godi/internal/repository"
	"net/url"
)

// CodeGenerator generator of authorization codes
type CodeGenerator interface {
	// GenerateCode generates a random model.AuthorizationCode
	GenerateCode() model.AuthorizationCode
}

// CodeGeneratorFunc functional interface for CodeGenerator
type CodeGeneratorFunc func() model.AuthorizationCode

// GenerateCode executes f() to generate a random code
func (f CodeGeneratorFunc) GenerateCode() model.AuthorizationCode {
	return f()
}

// NewUUIDCode creates a new model.AuthorizationCode that is basically an UUID
func NewUUIDCode() model.AuthorizationCode {
	return model.AuthorizationCode(uuid.New().String())
}

// _ "implement" constraint for ProofKeyCodeExchange
var _ Authorizer = (*AuthorizationCodeGrant)(nil)

// AuthorizationCodeGrant made the validations that correspond to the Authorization Code Grant flow
type AuthorizationCodeGrant struct {
	// PKCE must be an implementation of the Proof Key for Code Exchange extension
	PKCE Authorizer
	// CodeGenerator generate a code to save and validate the requests
	CodeGenerator
	repository.Storage
	repository.Finder
}

// Authorize validate the client model.Client obtained with the received data (model.Authorization)
//
// In resume...
//
// 1. Identifies the client using the client id and client secret
//
// 2. Validates the received state
//
// 3. Validates the redirect uri
//
// 4. Saves the session of this authorization request using the random code generated by
// the CodeGenerator
func (c AuthorizationCodeGrant) Authorize(auth model.Authorization) *url.URL {
	uri := auth.RedirectURL

	if !auth.State.IsValid() {
		return OAuthError(uri, model.InvalidRequest, "invalid state")
	}

	i, err := c.Finder.Find(auth.ClientId)
	if _, ok := err.(model.NotFound); ok || err == redis.Nil {
		return OAuthError(uri, model.UnauthorizedClient, fmt.Sprintf(`client "%s" does not exist`, auth.ClientId))
	}

	if err != nil {
		return OAuthError(uri, model.ServerError, err.Error())
	}

	client := i.(model.Client)

	if client.Secret != "" {
		// TODO make a better validation for the client secret
		if client.Secret != auth.ClientSecret {
			return OAuthError(uri, model.UnauthorizedClient, "client credentials does not match")
		}
	}

	if !client.IsValidOrigin(auth.RedirectURL.String()) {
		return OAuthError(uri, model.UnauthorizedClient, fmt.Sprintf(`invalid redirect uri "%s"`, auth.RedirectURL.RawPath))
	}

	// TODO user authentication

	// Proof Key for Code Exchange extension
	if c.PKCE != nil {
		uri := c.PKCE.Authorize(auth)

		if err := uri.Query().Get("error"); err != "" {
			return uri
		}
	}

	code := c.GenerateCode()

	if err := c.Storage.Create(string(code), auth); err != nil {
		if _, ok := err.(model.DuplicateRecord); ok {
			return OAuthError(uri, model.InvalidRequest, err.Error())
		}

		return OAuthError(uri, model.ServerError, err.Error())
	}

	q := url.Values{}

	q.Set("code", string(code))
	q.Set("state", string(auth.State))

	uri.RawQuery = q.Encode()
	return uri
}

// _ "implement" constraint for ProofKeyCodeExchange
var _ Authorizer = ProofKeyCodeExchange{}

// ProofKeyCodeExchange is the "Authorization Code Grant" flow with the extension "Proof Key for Code Exchange"
// for the OAuth 2.0 protocol
type ProofKeyCodeExchange struct{}

// Authorize validates the code_challenge and code_challenge_method
func (p ProofKeyCodeExchange) Authorize(auth model.Authorization) *url.URL {
	uri := auth.RedirectURL

	if !auth.CodeChallengeMethod.IsValid() {
		desc := fmt.Sprintf(`invalid code_challenge_method "%s", must be PLAIN or S256`, auth.CodeChallengeMethod)
		return OAuthError(uri, model.InvalidRequest, desc)
	}

	// TODO validate correctly the code challenge based on the model.CodeChallengeMethod
	// BUG: if code_challenge_method is S256 and code_challenge contains the ~ character
	// it is valid, which should be wrong because when using the S256 method the information
	// is sent in Base64 (URL) so it should not contain the ~ character at all
	//
	// This BUG should not cause any security problems but it does generate conflicts
	// when validating the code_verifier if the code_challenge contains the ~ character
	if !auth.CodeChallenge.IsValid() {
		return OAuthError(uri, model.InvalidRequest, "invalid code_challenge")
	}

	return auth.RedirectURL
}
