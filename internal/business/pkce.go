package business

import (
	"fmt"
	"github.com/google/uuid"
	"github.com/yael-castro/godi/internal/model"
	"github.com/yael-castro/godi/internal/repository"
	"net/url"
)

// CodeGenerator generator of authorization codes
type CodeGenerator interface {
	// GenerateCode generates a random model.AuthorizationCode
	GenerateCode() model.AuthorizationCode
}

// CodeGeneratorFunc functional interface for CodeGenerator
type CodeGeneratorFunc func() model.AuthorizationCode

// GenerateCode executes f() to generate a random code
func (f CodeGeneratorFunc) GenerateCode() model.AuthorizationCode {
	return f()
}

// NewUUIDCode creates a new model.AuthorizationCode that is basically an UUID
func NewUUIDCode() model.AuthorizationCode {
	return model.AuthorizationCode(uuid.New().String())
}

// _ "implement" constraint for ProofKeyCodeExchange
var _ Authorizer = (*AuthorizationCodeGrant)(nil)

// AuthorizationCodeGrant made the validations that correspond to the Authorization Code Grant flow
type AuthorizationCodeGrant struct {
	// PKCE must be an implementation of the Proof Key for Code Exchange extension
	PKCE Authorizer
	// CodeGenerator generate a code to save and validate the requests
	CodeGenerator
	Owner  Authenticator
	Client Authenticator
	repository.Storage
}

// Authorize validate the client model.Client obtained with the received data (model.Authorization)
//
// In resume...
//
// 1. Identifies the client using the client id and client secret
//
// 2. Validates the received state
//
// 3. Validates the redirect uri
//
// 4. Saves the session of this authorization request using the random code generated by
// the CodeGenerator
func (c AuthorizationCodeGrant) Authorize(auth model.Authorization) *url.URL {
	uri := auth.RedirectURL

	err := c.Client.Authenticate(model.Application{
		Id:          auth.ClientId,
		Secret:      auth.ClientSecret,
		RedirectURL: auth.RedirectURL,
	})

	if _, ok := err.(model.FailedAuthentication); ok {
		return OAuthError(uri, model.UnauthorizedClient, err.Error())
	}

	if err != nil {
		return OAuthError(uri, model.ServerError, err.Error())
	}

	err = c.Owner.Authenticate(auth.BasicAuth)
	if _, ok := err.(model.FailedAuthentication); ok {
		return OAuthError(uri, model.AccessDenied, err.Error())
	}

	if err != nil {
		return OAuthError(uri, model.ServerError, err.Error())
	}

	if !auth.State.IsValid() {
		return OAuthError(uri, model.InvalidRequest, "invalid state")
	}

	// Proof Key for Code Exchange extension
	if c.PKCE != nil {
		uri := c.PKCE.Authorize(auth)

		if err := uri.Query().Get("error"); err != "" {
			return uri
		}
	}

	// TODO validate the scope

	code := c.GenerateCode()

	if err := c.Storage.Create(string(code), auth); err != nil {
		return OAuthError(uri, model.ServerError, err.Error())
	}

	q := url.Values{}

	q.Set("code", string(code))
	q.Set("state", string(auth.State))

	uri.RawQuery = q.Encode()
	return uri
}

// _ "implement" constraint for ProofKeyCodeExchange
var _ Authorizer = ProofKeyCodeExchange{}

// ProofKeyCodeExchange is the "Authorization Code Grant" flow with the extension "Proof Key for Code Exchange"
// for the OAuth 2.0 protocol
type ProofKeyCodeExchange struct{}

// Authorize validates the code_challenge and code_challenge_method
func (p ProofKeyCodeExchange) Authorize(auth model.Authorization) *url.URL {
	uri := auth.RedirectURL

	if !auth.CodeChallengeMethod.IsValid() {
		desc := fmt.Sprintf(`invalid code_challenge_method "%s", must be PLAIN or S256`, auth.CodeChallengeMethod)
		return OAuthError(uri, model.InvalidRequest, desc)
	}

	// TODO validate correctly the code challenge based on the model.CodeChallengeMethod
	// BUG: if code_challenge_method is S256 and code_challenge contains the ~ character
	// it is valid, which should be wrong because when using the S256 method the information
	// is sent in Base64 (URL) so it should not contain the ~ character at all
	//
	// This BUG should not cause any security problems but it does generate conflicts
	// when validating the code_verifier if the code_challenge contains the ~ character
	if !auth.CodeChallenge.IsValid() {
		return OAuthError(uri, model.InvalidRequest, "invalid code_challenge")
	}

	return auth.RedirectURL
}
